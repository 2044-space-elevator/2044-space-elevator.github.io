 #最短路 #图论

哈哈，你没看错，这个文章被我放在了恶搞文章里。

当初也在想放在题解区还是恶搞文章区，但为了本博客的学术观感还有避免误导各位，我还是放在恶搞文章区了。

我们很容易的可以想到，这道题目是一个 Dijkstra 和 Floyd 的算法（我怎么会有如此邪恶的想法？），但由于 Dijkstra 不允许负边（其实也有办法解决，因为 $0 \leq |a|,|b|\leq 10^9$ ，所以我们可以对 $a,b$ 加上一个偏移量 $10^9$，最后再减 $2\times 10^9$，限于时间，我并没有尝逝这样做），所以我选择了 Floyd。

Floyd 是一个动态规划算法。那么这道题应该怎么做呢？

我们可以设一个图 $G$，他们有两条边，$(1,2)$ 存在一条边，权值为 $a$，$(2,3)$ 存在一条边，权值为 $b$，那么转换成最短路问题，就是从点 $1$ 到点 $3$，最少要采集的权值为多少？

我把点 $1$ 到 $3$ 的 其他边权值全设为了 $1145141919$，但由于最大可以到 $10^9$，导致存在一条权值为 $1145141919$ 的边成为最短路，这还使我刚开始 WA 了一个点。所以在最大值设置这里要注意。

好了，接下来是大家最期待的~~恶搞时刻~~：

```cpp
#include <iostream>
#include <cstring>
#define INF 11451419190 
// 很臭的一张图
using namespace std;
long long d[4][4];
void floyd()
{
    for (int k = 1; k <= 3; k++ )
    {
        for (int i = 1; i <= 3; i++ )
        {
            for (int j = 1; j <= 3; j++ )
            {
				if (d[i][k] != INF &&d[k][j] != INF)
				{
                	d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            	}
			}
        }
    }
}
int main()
{
    for (int i = 1; i <= 3; i++)
    {
		for (int j = 1; j <= 3; j++)
		{
			d[i][j] = INF;
		}
	}
    cin >> d[1][2] >> d[2][3];
    floyd();
    cout << d[1][3];
}


```

复杂度分析，考虑循环，初始化进行了 $9$ 次操作，Floyd 进行了 $27$ 次操作，无论输入多少，该程序的运行时间基本不变，所以时间复杂度为 $O(1)$，空间复杂度为 $O(1)$。