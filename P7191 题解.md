#数学  #数论 

[宣传一下我的个人博客。](http://2044blog.skyman.cloud)


第一眼看过去，是个暴力，然后直接打，提交的时候留了一手，因为看到了数据范围……

暴力代码直接贴这了：

```cpp
for (int m = 2; m <= *max_element(arr + 1, arr + n + 1); m++)
{
	_:;
	int mod_res = arr[1] % m;
	for (int i = 2; i <= n; i++)
	{
		if (mod_res != arr[i] % m)
		{
			goto _;
		}
	}
	cout << m << " ";
}
```

根据二楼的说法，这个代码能得 60 分。

如果大家思考的稍微深入一点就会发现，我们要做的就是解这个方程组：

$$

\begin{cases}
b_1m+y&=&a_1\\\
b_2m+y&=&a_2\\\
b_3m+y&=&a_3\\\
&\vdots\\\
b_nm+y&=&a_n
\end{cases}
$$

可以暴力枚举 $m$ 与 $y$，但这样会 TLE 到三体星。$m$ 的数据范围其实不会太大，烦人的就是这个 $y$，因为 $a_i\le 10^9$，所以 $y$ 最大也可以到 $10^9$，那么我们可以错位相减，把 $y$ 抵消，得到这个方程组：

$$
\begin{cases}
(b_2-b_1)m&=&a_2-a_1\\\
(b_3-b_2)m&=&a_3-a_2\\\
(b_4-b_3)m&=&a_4-a_3\\\
&\vdots\\\
(b_n-b_{n-1})m&=&a_{n}-a_{n-1}
\end{cases}
$$

如何得到 $m$ 的范围？只需要对上面的方程组的右式求最大公约数：

$$
\gcd(a_2-a_1,a_3-a_2,a_4-a_3,\ldots,a_n-a_{n-1})
$$
转换一下：

$$
m\gcd(b_2-b_1,b_3-b_2,b_4-b_3,\ldots,b_n-b_{n-1})
$$
定义刚刚这个式子的值为 $\gamma$。

接着利用这个性质：如果 $a\bmod k=b\bmod k$，则 $(a-b)\mid k$。

对应的，只需要求出所有的 $i\in[2,\gamma]$，使得 $i\mid \gamma$，那么可以发现 $i$ 是其中的一个合法的 $m$。

 > 感谢用户 xuchuhan 给我提供的思路，这里就不贴代码了罢，应该讲的足够详细了。
